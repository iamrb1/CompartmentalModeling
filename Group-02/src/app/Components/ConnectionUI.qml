/**
 @file TimePlotUI
 @author Nitish Maindoliya, Rahul Baragur
 **/
import QtQuick

import Application
import Utilities
import Components

Item {
    id: connectionUI
    property Connection connection
    property Compartment source: connection ? connection.source : null
    property Compartment target: connection ? connection.target : null
    property int compartmentWidth: Constants.compartmentWidth
    property int compartmentHeight: Constants.compartmentHeight
    property int arrowSize: 10
    property bool isSelfLoop: source && target && source === target


    /// hash to create uniqueID string for each connection to allow space in between connections
    /// generated by Claude
    property string connectionId: connection ? (source ? source.symbol : "") + "->" + (target ? target.symbol : "") : ""
    property bool isOddHash: connectionId.length > 0 ?
        (connectionId.charCodeAt(0) + connectionId.charCodeAt(connectionId.length - 1)) % 2 !== 0
        : false
    property int connectionOffset: isOddHash ? -15 : 15


    /// Line with arrow pointing at target component
    Canvas {
        id: lineRect
        width: calculateLength()
        height: Math.max(30, arrowSize * 2)
        antialiasing: true
        visible: !isSelfLoop

        /// Positioning attributes here
        x: 0 + connectionOffset
        y: -height / 2 + connectionOffset

        transformOrigin: Item.Left
        rotation: calculateAngle()

        onPaint: {
            const ctx = getContext("2d");
            ctx.fillStyle = ThemeManager.palette.text;
            ctx.strokeStyle = ThemeManager.palette.text;
            ctx.lineWidth = 4;

            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            ctx.lineTo(width - arrowSize * 2, height / 2);
            ctx.stroke();

            const arrowX = width - arrowSize * 2 - 80; // Offset from end
            ctx.beginPath();
            ctx.moveTo(arrowX, height / 2 - arrowSize);
            ctx.lineTo(arrowX + arrowSize * 2, height / 2);
            ctx.lineTo(arrowX, height / 2 + arrowSize);
            ctx.closePath();
            ctx.fill();
        }

        MouseArea {
            anchors.fill: parent
            onClicked: {
                simulation.sidebarConnection = connection
            }
        }
    }

    Canvas {
        id: selfLoopCanvas
        width: compartmentWidth + 100
        height: compartmentHeight + 100
        antialiasing: true
        visible: isSelfLoop


        x: -width / 2
        y: -height / 2

        /// self loop structure
        onPaint: {
            const ctx = getContext("2d");
            ctx.fillStyle = ThemeManager.palette.text;
            ctx.strokeStyle = ThemeManager.palette.text;
            ctx.lineWidth = 4;

            const loopWidth = width / 2;
            const loopHeight = height / 2;
            const startX = 10;
            const startY = 10;
            const cornerRadius = 15;

            ctx.beginPath();
            ctx.moveTo(startX + cornerRadius, startY);
            ctx.lineTo(startX + loopWidth - cornerRadius, startY);
            ctx.arcTo(startX + loopWidth, startY, startX + loopWidth, startY + cornerRadius, cornerRadius);
            ctx.lineTo(startX + loopWidth, startY + loopHeight - cornerRadius);
            ctx.arcTo(startX + loopWidth, startY + loopHeight, startX + loopWidth - cornerRadius, startY + loopHeight, cornerRadius);
            ctx.lineTo(startX + cornerRadius, startY + loopHeight);
            ctx.arcTo(startX, startY + loopHeight, startX, startY + loopHeight - cornerRadius, cornerRadius);
            ctx.lineTo(startX, startY + cornerRadius);
            ctx.arcTo(startX, startY, startX + cornerRadius, startY, cornerRadius);
            ctx.stroke();

            const arrowX = startX + loopWidth - 100;
            const arrowY = startY + loopHeight;

            ctx.beginPath();
            ctx.moveTo(arrowX + arrowSize * 2, arrowY);
            ctx.lineTo(arrowX, arrowY - arrowSize);
            ctx.lineTo(arrowX, arrowY + arrowSize);
            ctx.closePath();
            ctx.fill();
        }

        MouseArea {
            anchors.fill: parent
            onClicked: {
                simulation.sidebarConnection = connection
            }
        }
    }

    // Keep the connection positioned at source
    x: source ? source.x + compartmentWidth / 2 : 0
    y: source ? source.y + compartmentHeight / 2 : 0

    function calculateLength() {
        if (!(source && target)) {
            return 0;
        }

        const dx = target.x - source.x;
        const dy = target.y - source.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function calculateAngle() {
        if (!(source && target)) {
            return 0;
        }

        const dx = target.x - source.x;
        const dy = target.y - source.y;
        return Math.atan2(dy, dx) * 180 / Math.PI;
    }
}
