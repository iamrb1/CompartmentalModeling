import QtQuick
import cseg2
import Utilities
import Components

Item {
    id: connectionUI
    property Connection connection
    property Compartment source: connection ? connection.source : null
    property Compartment target: connection ? connection.target : null
    property int compartmentWidth: Constants.compartmentWidth
    property int compartmentHeight: Constants.compartmentHeight
    property int arrowSize: 10


    /// hash to create uniqueID string for each connection to allow space in between connections
    /// generated by Claude
    property string connectionId: connection ? (source ? source.symbol : "") + "->" + (target ? target.symbol : "") : ""
    property bool isOddHash: connectionId.length > 0 ?
        (connectionId.charCodeAt(0) + connectionId.charCodeAt(connectionId.length - 1)) % 2 !== 0
        : false
    property int connectionOffset: isOddHash ? -15 : 15


    /// Line with arrow pointing at target component
    Canvas {
        id: lineRect
        width: connectionUI.calculateLength()
        height: Math.max(30, arrowSize * 2)
        antialiasing: true

        /// Positioning attributes here
        x: 0 + connectionOffset
        y: -height/2 + connectionOffset

        transformOrigin: Item.Left
        rotation: connectionUI.calculateAngle()

        onPaint: {
            const ctx = getContext("2d");
            ctx.fillStyle = ThemeManager.palette.text;
            ctx.strokeStyle = ThemeManager.palette.text;
            ctx.lineWidth = 4;

            ctx.beginPath();
            ctx.moveTo(0, height/2);
            ctx.lineTo(width - arrowSize * 2, height/2);
            ctx.stroke();

            const arrowX = width - arrowSize * 2 - 80; // Offset from end
            ctx.beginPath();
            ctx.moveTo(arrowX, height/2 - arrowSize);
            ctx.lineTo(arrowX + arrowSize * 2, height/2);
            ctx.lineTo(arrowX, height/2 + arrowSize);
            ctx.closePath();
            ctx.fill();
        }

        MouseArea {
            anchors.fill: parent
            onClicked: {
                simulation.sidebarConnection = connection
            }
        }
    }

    // Keep the connection positioned at source
    x: source ? source.x + compartmentWidth / 2 : 0
    y: source ? source.y + compartmentHeight / 2 : 0

    function calculateLength() {
        if (!(source && target)) {
            return 0;
        }

        const dx = target.x - source.x;
        const dy = target.y - source.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    function calculateAngle() {
        if (!(source && target)) {
            return 0;
        }

        const dx = target.x - source.x;
        const dy = target.y - source.y;
        return Math.atan2(dy, dx) * 180 / Math.PI;
    }
}