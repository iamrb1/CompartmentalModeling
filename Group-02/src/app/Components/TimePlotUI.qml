/**
 @file TimePlotUI
 @author Rahul Baragur, Dominik Leisinger
 **/
import QtQuick.Controls
import QtQuick.Layouts
import QtCharts
import QtQuick

Item {
    id: root
    width: 400
    height: 300

    /// array for time storage unchanged x array btw
    property var timeData: []
    property string title: "Compartment Model Simulation"
    property string xAxisTitle: "Time"
    property string yAxisTitle: "Amount"
    property real minY: 0
    property real maxY: 100
    property real minX: 0
    property real maxX: 100

    /// here is where data is stored based on type of data function addDataseries shows model.
    /// these are the toggleable y arrays? we cant get the legend to work properly
    property var dataSeries: []

    //ListView presents ui updates better with a ListModel
    property ListModel legendModel: ListModel {}

    Component.onCompleted: {
        console.log("TimePlotUI initialized");
    }

    function updateLegendModel() {
        legendModel.clear();
        for (let i = 0; i < dataSeries.length; i++) {
            legendModel.append({
                seriesId: dataSeries[i].id,
                seriesName: dataSeries[i].name,
                seriesColor: dataSeries[i].color,
                seriesVisible: dataSeries[i].visible
            });
        }
        console.log("Legend model updated, count:", legendModel.count);
    }

    function addDataSeries(id, name, color) {
        console.log("Adding data series:", id, name, color);
        let newSeries = {
            id: id,
            name: name,
            data: [],
            color: color || getRandomColor(),
            visible: true
        };
        dataSeries.push(newSeries);
        updateLegendModel();
        updateSeries();
    }

    function addDataPoint(time, dataValues) {
        console.log("Adding data point at time:", time, "values:", dataValues);
        if (isNaN(time)) {
            console.error("Invalid time value:", time);
            return;
        }

        timeData.push(time);
        /// add the time here to the array

        for (let i = 0; i < dataSeries.length; i++) {
            if (dataValues[i] !== undefined && !isNaN(dataValues[i])) {
                dataSeries[i].data.push(dataValues[i]);
            } else {
                dataSeries[i].data.push(NaN);
            }
        }

        /// max of 1000 time points if extra deletes earlier points
        const maxPoints = 1000;
        if (timeData.length > maxPoints) {
            timeData.shift();
            for (let i = 0; i < dataSeries.length; i++) {
                dataSeries[i].data.shift();
            }
        }

        autoScaleAxes();
        updateSeries();
    }

    /// clear data when reset button pushed in GraphWindow UI -> check there
    function clearData() {
        console.log("Clearing data");
        timeData = [];
        for (let i = 0; i < dataSeries.length; i++) {
            dataSeries[i].data = [];
        }
        updateSeries();
    }

    /// Toggle visibility (generated by claude)
    function toggleSeries(id) {
        console.log("Toggling series:", id);
        for (let i = 0; i < dataSeries.length; i++) {
            if (dataSeries[i].id === id) {
                dataSeries[i].visible = !dataSeries[i].visible;

                // Update the corresponding item in the legendModel
                for (let j = 0; j < legendModel.count; j++) {
                    if (legendModel.get(j).seriesId === id) {
                        legendModel.setProperty(j, "seriesVisible", dataSeries[i].visible);
                        break;
                    }
                }

                break;
            }
        }
        updateSeries();
    }

    /// called when new compartment, connection etc is added -> check for validity bc this was hard to deduce
    function updateSeries() {
        console.log("Updating series, count:", chartView.count);

        chartView.removeAllSeries();

        for (let i = 0; i < dataSeries.length; i++) {
            if (dataSeries[i].visible) {
                let series = chartView.createSeries(ChartView.SeriesTypeLine, dataSeries[i].name, axisX, axisY);
                series.color = dataSeries[i].color;

                // Add each data point
                for (let j = 0; j < timeData.length && j < dataSeries[i].data.length; j++) {
                    if (!isNaN(dataSeries[i].data[j])) {
                        series.append(timeData[j], dataSeries[i].data[j]);
                    }
                }
            }
        }
    }

    /// Claude generated scaling function for the graph
    function autoScaleAxes() {
        if (timeData.length === 0) return;

        // Find min/max values
        let minTime = Math.min(...timeData);
        let maxTime = Math.max(...timeData);

        let allVisibleValues = [];
        for (let i = 0; i < dataSeries.length; i++) {
            if (dataSeries[i].visible) {
                allVisibleValues = allVisibleValues.concat(dataSeries[i].data.filter(v => !isNaN(v)));
            }
        }

        if (allVisibleValues.length === 0) return;

        let minValue = Math.min(...allVisibleValues);
        let maxValue = Math.max(...allVisibleValues);

        // Add some padding
        let xPadding = (maxTime - minTime) * 0.05 || 1;
        let yPadding = (maxValue - minValue) * 0.1 || 10;

        // Update axis limits
        minX = minTime - xPadding;
        maxX = maxTime + xPadding;
        minY = Math.max(0, minValue - yPadding);
        maxY = maxValue + yPadding;
    }

    // Generate a random color for new series
    function getRandomColor() {
        const colors = [
            "steelblue", "firebrick", "forestgreen", "orange", "purple",
            "deeppink", "darkslategray", "chocolate", "midnightblue", "olive"
        ];
        return colors[Math.floor(Math.random() * colors.length)];
    }

    ColumnLayout {
        anchors.fill: parent
        spacing: 0

        ChartView {
            id: chartView
            Layout.fillWidth: true
            Layout.fillHeight: true
            antialiasing: true
            title: root.title
            legend.visible: false

            ValueAxis {
                id: axisX
                titleText: root.xAxisTitle
                min: root.minX
                max: root.maxX > root.minX ? root.maxX : root.minX + 1
            }

            ValueAxis {
                id: axisY
                titleText: root.yAxisTitle
                min: root.minY
                max: root.maxY > root.minY ? root.maxY : root.minY + 1
            }
        }

        /// Legend
        Rectangle {
            Layout.fillWidth: true
            Layout.preferredHeight: 70
            Layout.minimumHeight: 70
            color: "lightgray"
            border.width: 1
            border.color: "gray"

            // Legend label
            Text {
                anchors.top: parent.top
                anchors.left: parent.left
                anchors.margins: 5
                text: "Legend (" + legendModel.count + " series)"
                color: "black"
                font.pixelSize: 10
            }

            ListView {
                id: legendListView
                anchors.fill: parent
                anchors.margins: 5
                anchors.topMargin: 20
                orientation: ListView.Horizontal
                spacing: 15
                model: legendModel
                clip: true

                // Debug output when model changes
                onCountChanged: {
                    console.log("Legend ListView count changed:", count);
                }

                delegate: Row {
                    spacing: 5
                    height: parent ? parent.height - 5 : 30

                    // Wrapper item to help with alignment
                    Item {
                        width: visibilityToggle.width
                        height: parent.height

                        CheckBox {
                            id: visibilityToggle
                            anchors.verticalCenter: parent.verticalCenter
                            checked: seriesVisible
                            onToggled: {
                                root.toggleSeries(seriesId);
                            }
                        }
                    }

                    // Color indicator block
                    Rectangle {
                        width: 15
                        height: 15
                        color: seriesColor
                        anchors.verticalCenter: parent.verticalCenter
                    }

                    Text {
                        text: seriesName
                        anchors.verticalCenter: parent.verticalCenter
                        color: seriesVisible ? "black" : "gray"
                    }
                }
            }
        }
    }
}
