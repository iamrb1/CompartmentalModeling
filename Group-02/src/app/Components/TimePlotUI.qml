/**
 @file TimePlotUI
 @author Dominik Leisinger, Rahul Baragur
 **/
import QtQuick.Controls
import QtQuick.Layouts
import QtCharts
import QtQuick

Item {
    id: root
    width: 400
    height: 300

    /// array for time storage unchanged x array btw
    property var timeData: []
    property string title: "Compartment Model Simulation"
    property string xAxisTitle: "Time"
    property string yAxisTitle: "Amount"
    property real minY: 0
    property real maxY: 100
    property real minX: 0
    property real maxX: 100

    /// here is where data is stored based on type of data function addDataseries shows model.
    /// these are the toggleable y arrays? we cant get the legend to work properly
    property var dataSeries: []


    Component.onCompleted: {
        console.log("TimePlotUI initialized");
    }


    function addDataSeries(id, name, color) {
        console.log("Adding data series:", id, name, color);
        let newSeries = {
            id: id,
            name: name,
            data: [],
            color: color || getRandomColor(),
            visible: true
        };
        dataSeries.push(newSeries);
        updateSeries();
    }

    function addDataPoint(time, dataValues) {
        console.log("Adding data point at time:", time, "values:", dataValues);
        if (isNaN(time)) {
            console.error("Invalid time value:", time);
            return;
        }

        timeData.push(time);
        /// add the time here to the array


        for (let i = 0; i < dataSeries.length; i++) {
            if (dataValues[i] !== undefined && !isNaN(dataValues[i])) {
                dataSeries[i].data.push(dataValues[i]);
            } else {
                dataSeries[i].data.push(NaN);
            }
        }

        /// max of 1000 time points if extra deletes earlier points
        const maxPoints = 1000;
        if (timeData.length > maxPoints) {
            timeData.shift();
            for (let i = 0; i < dataSeries.length; i++) {
                dataSeries[i].data.shift();
            }
        }

        autoScaleAxes();
        updateSeries();
    }

    /// clear data when reset button pushed in GraphWindow UI -> check there
    function clearData() {
        console.log("Clearing data");
        timeData = [];
        for (let i = 0; i < dataSeries.length; i++) {
            dataSeries[i].data = [];
        }
        updateSeries();
    }

    /// Toggle visibility (generated by claude)
    function toggleSeries(id) {
        console.log("Toggling series:", id);
        for (let i = 0; i < dataSeries.length; i++) {
            if (dataSeries[i].id === id) {
                dataSeries[i].visible = !dataSeries[i].visible;
                break;
            }
        }
        updateSeries();
    }

    /// called when new compartment, connection etc is added -> check for validity bc this was hard to deduce
    function updateSeries() {
        console.log("Updating series, count:", chartView.count);

        chartView.removeAllSeries();


        for (let i = 0; i < dataSeries.length; i++) {
            if (dataSeries[i].visible) {
                let series = chartView.createSeries(ChartView.SeriesTypeLine, dataSeries[i].name, axisX, axisY);
                series.color = dataSeries[i].color;

                // Add each data point
                for (let j = 0; j < timeData.length && j < dataSeries[i].data.length; j++) {
                    if (!isNaN(dataSeries[i].data[j])) {
                        series.append(timeData[j], dataSeries[i].data[j]);
                    }
                }
            }
        }
    }

    /// Claude generated scaling function for the graph
    function autoScaleAxes() {
        if (timeData.length === 0) return;

        // Find min/max values
        let minTime = Math.min(...timeData);
        let maxTime = Math.max(...timeData);

        let allVisibleValues = [];
        for (let i = 0; i < dataSeries.length; i++) {
            if (dataSeries[i].visible) {
                allVisibleValues = allVisibleValues.concat(dataSeries[i].data.filter(v => !isNaN(v)));
            }
        }

        if (allVisibleValues.length === 0) return;

        let minValue = Math.min(...allVisibleValues);
        let maxValue = Math.max(...allVisibleValues);

        // Add some padding
        let xPadding = (maxTime - minTime) * 0.05 || 1;
        let yPadding = (maxValue - minValue) * 0.1 || 10;

        // Update axis limits
        minX = minTime - xPadding;
        maxX = maxTime + xPadding;
        minY = Math.max(0, minValue - yPadding);
        maxY = maxValue + yPadding;
    }

    // Generate a random color for new series
    function getRandomColor() {
        const colors = [
            "steelblue", "firebrick", "forestgreen", "orange", "purple",
            "deeppink", "darkslategray", "chocolate", "midnightblue", "olive"
        ];
        return colors[Math.floor(Math.random() * colors.length)];
    }

    ColumnLayout {
        anchors.fill: parent
        spacing: 0

        ChartView {
            id: chartView
            Layout.fillWidth: true
            Layout.fillHeight: true
            antialiasing: true
            title: root.title
            legend.visible: false

            ValueAxis {
                id: axisX
                titleText: root.xAxisTitle
                min: root.minX
                max: root.maxX > root.minX ? root.maxX : root.minX + 1
            }

            ValueAxis {
                id: axisY
                titleText: root.yAxisTitle
                min: root.minY
                max: root.maxY > root.minY ? root.maxY : root.minY + 1
            }
        }

        /// Leged
        Rectangle {
            Layout.fillWidth: true
            Layout.preferredHeight: 50
            Layout.minimumHeight: 50  // Ensure minimum height
            color: "lightgray"        // Changed to visible color for debugging
            border.width: 1           // Add border for visibility
            border.color: "gray"

            // Debug text to show current state
            Text {
                anchors.top: parent.top
                anchors.left: parent.left
                anchors.margins: 5
                text: "Legend (" + dataSeries.length + " series)"
                color: "black"
                font.pixelSize: 10
            }

            ListView {
                id: legendListView
                anchors.fill: parent
                anchors.margins: 5
                orientation: ListView.Horizontal
                spacing: 15
                model: dataSeries
                clip: true  // Prevent overflow

                // Debug output when model changes
                onCountChanged: {
                    console.log("Legend ListView count changed:", count);
                }

                delegate: Row {
                    spacing: 5
                    height: parent ? parent.height : 40

                    CheckBox {
                        id: visibilityToggle
                        checked: modelData ? modelData.visible : false
                        onToggled: {
                            if (modelData) {
                                root.toggleSeries(modelData.id);
                            }
                        }
                    }

                    Rectangle {
                        width: 15
                        height: 15
                        color: modelData ? modelData.color : "gray"
                        anchors.verticalCenter: parent.verticalCenter
                    }

                    Text {
                        text: modelData ? modelData.name : ""
                        anchors.verticalCenter: parent.verticalCenter
                        color: modelData && modelData.visible ? "black" : "gray"
                    }
                }
            }
        }
    }
}